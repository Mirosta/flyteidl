syntax = "proto3";
package flyteidl.service;

option go_package = "github.com/flyteorg/flyteidl/gen/pb-go/flyteidl/service";

import "flyteidl/core/literals.proto";
import "flyteidl/core/identifier.proto";


message ArtifactKey {
  // Project and domain as we're all used to. Just to align with existing uniqueness constructs.
  string project = 1;
  string domain = 2;

  // name can be auto-generated by the system in the case of things like natural outputs
  // or manually named by the user, if they care to.
  string name = 3;

}

message ArtifactID {
  ArtifactKey artifact_key = 1;

  // Version is always autogenerated unless specifically overridden by the user. This will usually be the wf exec id
  // The things that users want, the ability to tag various versions with user-friendly semvers or something
  // should be managed separately.
  string version = 4;
}

message Artifact {
  ArtifactID artifact_id = 1;

  core.Literal value = 2;
}

message CreateArtifactRequest {
  core.Literal value = 1;

}

message GetArtifactRequest {
  oneof identifier {
    ArtifactID artifact_id = 1;

    string uri = 2;
  }
}

message GetArtifactIDRequest {
  oneof identifier {
    string uri = 1;

    // some tag = 2;
  }
}

// Tags are general key/value pairs associated with an Artifact. They can be used to search and filter things.
message Tag {
  // tag types can be user specified if they want, though we'd probably recommend sticking with the
  string key = 1;
  string value = 2;
}

message AddTagsRequest {
  ArtifactID artifact_id = 1;

  repeated Tag tags = 2;
}

// I think this message/rpc 
message RecordUsageRequest {
  ArtifactID artifact_id = 1;

  oneof usage_identifier {
    // A request with this field filled in should be called when a user uses an existing artifact as an input
    // to a workflow execution.
    // TODO Question: Do we need to record the name of the input? The binding. What if the same artifact is used
    // twice in a single execution.
    core.WorkflowExecutionIdentifier workflow_execution_id = 2;

    // A request with this filled in should be called when a workflow returns this artifact as a
    core.NodeExecutionIdentifier node_execution_id = 3;
  }


}

// Aliases identify a particular version of an artifact. They have to be unique for a given
message CreateAliasRequest {

}


service ArtifactRegistry {
  rpc CreateArtifact (CreateArtifactRequest) returns (CreateArtifactResponse) {}

  rpc GetArtifact (GetArtifactRequest) returns (Artifact) {}

  // This can be an optionally callable lookup endpoint.
  rpc GetArtifactID(GetArtifactIDRequest) returns (ArtifactID) {}

  rpc TagArtifact(AddTagsRequest) returns (TagArtifactResponse) {}

  rpc RecordUsage
}

